package Sarb;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.text.DecimalFormat;
import java.util.Random;

import robocode.RobocodeFileOutputStream;

/**
 * @author sarbjit
 * {@docRoot}
 * @version 0.4
 * This class implements a look up table for use in RL.
 * It is deliberately written to have the same methods as NeuralNet.java
 * This way the calling code can easily switch between NN and a look-up-table.
 * 
 * v0.2 adds code that tracks the maximum and minimum
 * Q values that are reached during training. (See maxQ, minQ)
*
 * v0.3 removed printNonZeroElements. This does not work since we randomly initialise the LUT,
 * rather than zero initialise. Also added a new table that tracks which element in the LUT was visited
 * i.e. trained. Look for "visited". So we can print out the state action vector, we also capture all visited
 * input vector during training in the array called inputVector. This is output to file by a new method called
 * writeToFile.
 * 
 * v0.4 changed save file to write out floats to maximum of three decimal places.
 */
public class LUT {
	
	/**
	 * Public attributes of this class
	 */
	 public double maxQ = 0.0;
	 public double minQ = 0.0;
	
	/**
	 * Private members of this class
	 */
	private double [] lookUpTable;			// This is the look up table
	private boolean [] visited; 			// This tracks which elements of the look up table were visited
	private String [] inputVectorString;	// Capture the vector used to index the LUT. (Used only so we can output it to a file).
	private int maxIndex = 0;
	private int [] floor;
	private int [] ceiling;
	
	// To control size of the file generated by save
	DecimalFormat dfR = new DecimalFormat( "#0.00" );
	
	/**
	 * Constructor.
	 * @param argNumInputs The number of inputs in your input vector
	 * @param argVariableFloor An array specifying the lowest value of each variable in the input vector.
	 * @param argVariableCeiling An array specifying the highest value of each of the variables in the input vector.
	 * The order must match the order as referred to in argVariableFloor. 
	 * 	 */
	public LUT (
			int argNumInputs,
			int [] argVariableFloor,
			int [] argVariableCeiling ) 
	{
		floor = argVariableFloor;
		ceiling = argVariableCeiling;
		
		// range due to first variable
		maxIndex = argVariableCeiling [0] - argVariableFloor [0] + 1; // +1 is needed to make the count inclusive of end values. E.g. -4 to +4 is 9 values not 8
		
		// Now multiply by ranges due to remaining variables
		for( int i=1; i<argNumInputs; i++ ) 
			maxIndex = maxIndex * (argVariableCeiling [i] - argVariableFloor [i] + 1);
			
		lookUpTable = new double [ maxIndex ];	// Will be initialised randomly.
		visited = new boolean [ maxIndex ];			// Will be initialised to 0;
		inputVectorString = new String [ maxIndex ];	// We don't initialise this. It gets set when it is "visited".
		initialiseLUT();
		System.out.println( "--+ LUT constructed of size " + maxIndex + " elements." );
	}
	
	/**
	 * Initialise the look up table to all zeros.
	 */
	private void initialiseLUT() {	
		Random rand = new Random ();
			for ( int i=0; i<maxIndex; i++ ) {
				lookUpTable [i] = rand.nextDouble();
				visited [i] = false;
			}
		}
	
	/**
	 * A helper method that translates a vector being used to index the look up table
	 * into an ordinal that can then be used to access the associated look up table element.
	 * @param X The state action vector used to index the LUT
	 * @return The index where this vector maps to
	 */
	public int indexFor( double [] X ) {
		int units = 1;
		int index = units * ((int) X[0] - floor [0]);
		for( int i=1; i<X.length; i++ ) {
			units = units * (ceiling [i-1] - floor [i-1] + 1);
			index = index + (int) (X[i]-floor[i]) * units;
		}	
		return index;
	}
	
	/**
	 * Retrieves the value stored in that location of the look up table that
	 * corresponds to the specified input vector
	 * @param X The input vector. An array of doubles.
	 * @return The value associated with this input vector
	 */
	public double outputFor ( double [] X ) {	
		return lookUpTable[ indexFor( X ) ];
	}
	
	/**
	 * Will replace the value currently stored in the location of the look up table
	 * corresponding to the specified input vector, with the new value provided.
	 * Also updates minQ and maxQ to track upper and lower bounds reached by Q.
	 * @param X The input vector
	 * @param argValue The new value to store
	 */
	public void train ( double [] X, double argValue ) {
		int i = indexFor( X );
		lookUpTable[i] = argValue;
		
		// The following is for diagnostic purposes only
		{
			visited[i] = true;
			inputVectorString[i] = ""; // Start with the empty string;
			for (int j=0; j<X.length; j++) inputVectorString[i] += X[j] + " ";
				
				// inputVectorString[i] = X.toString() + " ";
			if ( argValue > maxQ ) maxQ = argValue;
			if ( argValue < minQ ) minQ = argValue;
		}
	}
	
	/**
	 * Will attempt to write only the 'visited' elements of the look up table
	 * to the specified file.
	 * Format is as follows
	 * 1st line is size of LUT
	 * nth line is index
	 * nth+1 line is Q-value for index on previous line
	 * @param argFile of type File.
	 */
	public void save( File argFile ) {
		PrintStream saveFile = null;
		
		try {
			saveFile = new PrintStream( new RobocodeFileOutputStream( argFile ));
		}
		catch (IOException e) {
			System.out.println( "*** Could not create output stream for LUT save file.");
		}
		
		saveFile.println( maxIndex );
		int numEntriesSaved = 0;
		for (int i=0; i<maxIndex; i++)
			if (visited[i]) {
				saveFile.println( i +"\n"+ dfR.format( lookUpTable [i] ) );
				numEntriesSaved ++;
			}
		saveFile.close();
		System.out.println ( "--+ Number of LUT table entries saved is " + numEntriesSaved );
	}
	
	/**
	 * Loads the LUT from file
	 * Expects that the 1st line match the maxIndex otherwise returns
	 */
	public void load( String argFileName ) throws IOException {
		
		FileInputStream inputFile = new FileInputStream( argFileName );
		BufferedReader inputReader = new BufferedReader( new InputStreamReader( inputFile ));
		
		// Check that the maxIndex matches
		int maxIndexFromFile = Integer.valueOf( inputReader.readLine() );
		if ( maxIndexFromFile != maxIndex ) {
			System.out.println( "*** MaxIndex for file does not match LUT." );
			return;
		}
		
		// Now load the LUT
		int numEntriesLoaded = 0;
		while ( inputReader.ready() ) { // ready () returns false when at EOF
			int index = Integer.valueOf( inputReader.readLine () );
			double Q = Double.valueOf( inputReader.readLine () );
			lookUpTable [index] = Q;
			visited [index] = true;
			numEntriesLoaded ++;
		}
		inputReader.close();
		System.out.println ( "--+ Number of LUT entries loaded was " + numEntriesLoaded );
	}
	
} // End of public class LUT